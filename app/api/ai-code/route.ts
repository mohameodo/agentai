import { NextRequest, NextResponse } from 'next/server'
import { promises as fs } from 'fs'
import path from 'path'

const WORKSPACE_ROOT = '/workspaces/agentai'

export async function POST(request: NextRequest) {
  try {
    const { code, description, projectName } = await request.json()

    if (!code) {
      return NextResponse.json({ error: 'Code is required' }, { status: 400 })
    }

    // Extract files from AI generated code
    const files = extractFilesFromCode(code)
    
    if (files.length === 0) {
      return NextResponse.json({ 
        error: 'No files found in the provided code' 
      }, { status: 400 })
    }

    // Create project directory
    const projectDir = projectName 
      ? path.join(WORKSPACE_ROOT, 'codehat-projects', projectName)
      : path.join(WORKSPACE_ROOT, 'codehat-projects', `project-${Date.now()}`)

    await fs.mkdir(projectDir, { recursive: true })

    // Write all files
    const createdFiles = []
    for (const file of files) {
      const filePath = path.join(projectDir, file.name)
      
      // Ensure directory exists
      await fs.mkdir(path.dirname(filePath), { recursive: true })
      
      // Write file
      await fs.writeFile(filePath, file.content)
      
      createdFiles.push({
        name: file.name,
        path: filePath,
        content: file.content,
        language: file.language,
        type: file.type
      })
    }

    // Create package.json if it doesn't exist
    if (!files.some(f => f.name === 'package.json')) {
      const hasReact = files.some(f => f.content.includes('react') || f.name.includes('.jsx') || f.name.includes('.tsx'))
      const hasNext = files.some(f => f.content.includes('next') || f.content.includes('Next.js'))
      const hasTypeScript = files.some(f => f.name.includes('.ts') || f.name.includes('.tsx'))
      
      const packageJson = {
        name: projectName?.toLowerCase().replace(/[^a-z0-9-]/g, '-') || 'ai-generated-project',
        version: '1.0.0',
        description: description || 'Generated by CodeHat AI',
        main: hasNext ? 'app/page.tsx' : 'index.js',
        scripts: hasNext ? {
          dev: 'next dev',
          build: 'next build',
          start: 'next start',
          lint: 'next lint'
        } : hasReact ? {
          start: 'react-scripts start',
          build: 'react-scripts build',
          test: 'react-scripts test',
          eject: 'react-scripts eject'
        } : {
          start: 'node index.js',
          dev: 'node index.js',
          build: 'echo "No build script configured"'
        },
        dependencies: {
          ...(hasReact && { 
            react: '^18.2.0', 
            'react-dom': '^18.2.0' 
          }),
          ...(hasNext && { 
            next: '^14.0.0',
            react: '^18.2.0',
            'react-dom': '^18.2.0'
          }),
          ...(hasTypeScript && { 
            typescript: '^5.0.0',
            '@types/node': '^20.0.0',
            '@types/react': '^18.2.0',
            '@types/react-dom': '^18.2.0'
          })
        },
        devDependencies: {
          ...(hasTypeScript && { 
            typescript: '^5.0.0' 
          }),
          ...(hasNext && hasTypeScript && {
            '@types/node': '^20.0.0',
            '@types/react': '^18.2.0',
            '@types/react-dom': '^18.2.0'
          })
        },
        keywords: ['ai-generated', 'codehat'],
        author: 'CodeHat AI'
      }
      
      const packageJsonPath = path.join(projectDir, 'package.json')
      await fs.writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2))
      
      createdFiles.push({
        name: 'package.json',
        path: packageJsonPath,
        content: JSON.stringify(packageJson, null, 2),
        language: 'json',
        type: 'config'
      })
    }

    // Create a README.md if it doesn't exist
    if (!files.some(f => f.name === 'README.md')) {
      const readmeContent = `# ${projectName || 'AI Generated Project'}

${description || 'This project was generated by CodeHat AI.'}

## Getting Started

### Installation
\`\`\`bash
npm install
\`\`\`

### Development
\`\`\`bash
npm run dev
\`\`\`

### Build
\`\`\`bash
npm run build
\`\`\`

## Generated Files

This project contains ${createdFiles.length} generated files:

${createdFiles.map(f => `- **${f.name}** - ${f.type}`).join('\n')}

---

*Generated with ❤️ by CodeHat AI*
`
      
      const readmePath = path.join(projectDir, 'README.md')
      await fs.writeFile(readmePath, readmeContent)
      
      createdFiles.push({
        name: 'README.md',
        path: readmePath,
        content: readmeContent,
        language: 'markdown',
        type: 'other'
      })
    }

    return NextResponse.json({
      success: true,
      message: `Created ${createdFiles.length} files in ${projectDir}`,
      files: createdFiles,
      projectPath: projectDir
    })

  } catch (error) {
    console.error('AI code processing error:', error)
    return NextResponse.json({ 
      error: 'Failed to process AI generated code',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 })
  }
}

function extractFilesFromCode(code: string) {
  const files: Array<{
    name: string
    content: string
    language: string
    type: 'component' | 'page' | 'style' | 'config' | 'other'
  }> = []

  // Enhanced regex to detect file paths and code blocks
  const filePathRegex = /(?:File:|Create file|Update file|Save as|Filename:|File name:|```[\w]*\s*\/\/\s*|```[\w]*\s*\/\*\s*|```[\w]*\s*#\s*)\s*[`"]?([^`"\n]+\.[a-zA-Z0-9]+)[`"]?/gi
  const codeBlockRegex = /```(\w+)?\s*(?:\/\/\s*([^\n]+)|\/\*\s*([^\n]+)\s*\*\/|#\s*([^\n]+))?\n([\s\S]*?)```/g

  let match
  const codeBlocks = []
  
  // Extract all code blocks
  while ((match = codeBlockRegex.exec(code)) !== null) {
    const language = match[1] || 'text'
    const possiblePath = match[2] || match[3] || match[4]
    const blockContent = match[5]
    
    if (blockContent.trim()) {
      codeBlocks.push({ language, possiblePath, code: blockContent.trim() })
    }
  }
  
  // Try to match file paths with code blocks
  const pathMatches: string[] = []
  let pathMatch
  const contentCopy = code
  const pathRegex = new RegExp(filePathRegex.source, filePathRegex.flags)
  while ((pathMatch = pathRegex.exec(contentCopy)) !== null) {
    pathMatches.push(pathMatch[1])
  }
  
  // Create files from code blocks
  codeBlocks.forEach((block, index) => {
    let filePath = block.possiblePath || pathMatches[index]
    
    if (!filePath) {
      // Generate a smart filename based on language and content
      const extension = getExtensionForLanguage(block.language)
      
      // Try to detect common patterns for file naming
      const lines = block.code.split('\n')
      let suggestedName = ''
      
      // Check for component names, class names, etc.
      for (const line of lines) {
        const componentMatch = line.match(/(?:function|class|const|export)\s+([A-Z][a-zA-Z0-9]*)/);
        const fileMatch = line.match(/\/\/\s*([a-zA-Z0-9-_.]+\.[a-zA-Z]+)/);
        
        if (componentMatch) {
          suggestedName = componentMatch[1].toLowerCase();
          break;
        } else if (fileMatch) {
          suggestedName = fileMatch[1];
          break;
        }
      }
      
      if (!suggestedName) {
        // Fallback names based on language
        const fallbackNames: Record<string, string> = {
          'html': 'index.html',
          'css': 'styles.css',
          'javascript': 'script.js',
          'js': 'script.js',
          'typescript': 'main.ts',
          'ts': 'main.ts',
          'jsx': 'App.jsx',
          'tsx': 'App.tsx',
          'python': 'main.py',
          'json': 'config.json'
        }
        suggestedName = fallbackNames[block.language] || `file${index + 1}.${extension}`
      } else if (!suggestedName.includes('.')) {
        suggestedName += `.${extension}`
      }
      
      filePath = suggestedName
    }
    
    // Clean up file path
    const fileName = filePath.split('/').pop() || filePath
    
    files.push({
      name: fileName,
      content: block.code,
      language: block.language,
      type: getFileType(fileName)
    })
  })

  return files
}

function getExtensionForLanguage(language: string): string {
  const extensions: Record<string, string> = {
    javascript: 'js',
    typescript: 'ts',
    jsx: 'jsx',
    tsx: 'tsx',
    html: 'html',
    css: 'css',
    json: 'json',
    markdown: 'md',
    python: 'py',
    java: 'java',
    cpp: 'cpp',
    c: 'c',
    go: 'go',
    rust: 'rs',
    php: 'php',
    ruby: 'rb',
    swift: 'swift',
    kotlin: 'kt',
    sql: 'sql',
    xml: 'xml',
    yaml: 'yml',
    toml: 'toml',
    dockerfile: 'dockerfile',
    bash: 'sh',
    shell: 'sh',
    text: 'txt'
  }
  
  return extensions[language.toLowerCase()] || 'txt'
}

function getFileType(fileName: string): "component" | "page" | "style" | "config" | "other" {
  const ext = fileName.split('.').pop()?.toLowerCase()
  if (ext === 'tsx' || ext === 'jsx') return 'component'
  if (ext === 'css' || ext === 'scss') return 'style'
  if (ext === 'json' || ext === 'js' || ext === 'ts') return 'config'
  return 'other'
}
